#!/usr/bin/env ruby

# frozen_string_literal: true

require_relative '../lib/node'
require_relative '../lib/directed_acyclic_path_graph'
require 'prettyprint'

module Suburb
  module DSL
    class Root
      def files
        @files ||= []
      end

      def file(outs, ins: [], &block)
        files << DSL::File.new(outs, ins, &block)
      end

      def to_dag(root_path)
        dag = DirectedAcyclicPathGraph.new(root_path)
        files.each do |f|
          f.outs.each do |out|
            add_out(dag, out, f.ins, &f.builder)
          end
        end
        dag
      end

      def add_out(dag, out, ins, &builder)
        dag.add_node(out, &builder)
        ins.each do |in_|
          add_in(dag, in_, out)
        end
      end

      def add_in(dag, in_, out)
        path = ::File.expand_path(in_, dag.root_path)

        if is_glob(path)
          Dir.glob(path) do |expanded|
            fn = Pathname.new(expanded).basename
            dag.add_dependency(out, expanded) if fn != 'subu.rb'
          end
        else
          dag.add_dependency(out, path)
        end
      end

      def is_glob(path)
        path.include?('*')
      end
    end

    class File
      def initialize(file_or_ary_or_proc, ins, &builder)
        @outs = Array(file_or_ary_or_proc)
        @ins = Array(ins)
        @builder = builder
      end

      attr_reader :outs, :ins, :builder
    end

    class Run
      def rtx(command)
        sh "rtx exec -- #{command}"
      end
    end
  end

  class Runner
    require 'pathname'

    def run(target_file_path)
      subu_rb = find_subu_rb(target_file_path) or die("No subu.rb found defining target file '#{target_file_path}' found")
      spec = DSL::Root.new
      spec.instance_eval(File.read(subu_rb))
      dag = spec.to_dag(subu_rb.dirname)
      raise 'some targets do not exist' unless dag.all_dependencies_exist?

      dag.pp
      execute dag, spec, target_file_path
    end

    def find_subu_rb(target_file_path)
      Pathname.new(target_file_path).ascend do |parent|
        maybe_subu = parent + 'subu.rb'
        return maybe_subu.realpath if maybe_subu.exist?
      end
    end

    def execute(dag, subu_spec, target_file_path)
      realpath = Pathname.new(target_file_path).expand_path
      puts "Checking #{realpath} for changes..."
      raise "No suburb definition for #{realpath}" unless dag.nodes.include? realpath

      root_node = dag.nodes[realpath]
      deps = transitive_deps_requiring_build(root_node)
      puts "Considering #{deps.size} deps..."

      execute_nodes_in_order deps + [root_node], subu_spec
    end

    def execute_nodes_in_order(nodes)
      nodes.each do |node|
        path = Pathname.new(node.path)
        next unless node.builder

        puts "Building #{path}..."
        node.builder.call(node.path, node.dependencies)
      end
    end

    def transitive_deps_requiring_build(root_node)
      modified_since(root_node.path, root_node.dependencies)
    end

    def modified_since(path, deps)
      children = deps.select do |dep|
        if File.exist?(dep.path) && File.exist?(path)
          File.mtime(dep.path) > File.mtime(path)
        else
          true
        end
      end
      grand_children = deps.map { |dep| modified_since(dep.path, dep.dependencies) }
      (grand_children + children).flatten
    end

    def die(reason)
      warn reason
      exit 1
    end
  end
end

raise 'no file task given' unless ARGV[0]

Suburb::Runner.new.run(File.expand_path(ARGV[0]))
