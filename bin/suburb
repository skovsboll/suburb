#!/usr/bin/env ruby

# frozen_string_literal: true

require_relative '../lib/node'
require_relative '../lib/directed_acyclic_path_graph'
require 'prettyprint'
require 'tty-progressbar'

module Suburb
  module DSL
    class Root
      def files
        @files ||= []
      end

      def file(outs, ins: [], &block)
        files << DSL::File.new(outs, ins, &block)
      end

      def to_dag(root_path)
        dag = DirectedAcyclicPathGraph.new(root_path)
        files.each do |f|
          f.outs.each do |out|
            add_out(dag, out, f.ins, &f.builder)
          end
        end
        dag
      end

      def add_out(dag, out, ins, &builder)
        dag.add_node(out, &builder)
        ins.each do |in_|
          add_in(dag, in_, out)
        end
      end

      def add_in(dag, in_, out)
        path = ::File.expand_path(in_, dag.root_path)

        if is_glob(path)
          Dir.glob(path) do |expanded|
            fn = Pathname.new(expanded).basename
            dag.add_dependency(out, expanded) if fn != 'subu.rb'
          end
        else
          dag.add_dependency(out, path)
        end
      end

      def is_glob(path)
        path.include?('*')
      end
    end

    class File
      def initialize(file_or_ary_or_proc, ins, &builder)
        @outs = Array(file_or_ary_or_proc)
        @ins = Array(ins)
        @builder = builder
      end

      attr_reader :outs, :ins, :builder
    end

  end

  class Runner
    require 'pathname'

    class Run
      def rtx(command)
        `rtx exec -- #{command}`
      end
    end

    def run(target_file_path, force)
      subu_rb = find_subu_rb(target_file_path) or die("No subu.rb found defining target file '#{target_file_path}' found")
      spec = DSL::Root.new
      spec.instance_eval(File.read(subu_rb))
      dag = spec.to_dag(subu_rb.dirname)
      raise 'some targets do not exist' unless dag.all_dependencies_exist?
      execute dag, spec, target_file_path, force
    end

    def find_subu_rb(target_file_path)
      Pathname.new(target_file_path).ascend do |parent|
        maybe_subu = parent + 'subu.rb'
        return maybe_subu.realpath if maybe_subu.exist?
      end
    end

    def execute(dag, subu_spec, target_file_path, force = false)
      target = Pathname.new(target_file_path).expand_path
      raise "No suburb definition for #{target}" unless dag.nodes.include? target.to_s

      root_node = dag.nodes[target.to_s]
      deps = if force
        root_node.all_dependencies
      else
        transitive_deps_requiring_build(dag, root_node)
      end

      execute_nodes_in_order deps + [root_node]
    end

    def execute_nodes_in_order(nodes)
      bar = TTY::ProgressBar::Multi.new("Building [:bar]", total: nodes.size)

      nodes_with_bars = nodes.map { [_1, bar.register("#{_1.path.basename} :percent", total: 1) ] }

      nodes_with_bars.each do |node, sub_bar|
        path = Pathname.new(node.path)
        next unless node.builder
        Run.new.instance_exec(node.dependencies.map(&:path), Array(path), &node.builder)
        sub_bar.advance
      end
      bar.finish
    end

    def transitive_deps_requiring_build(dag, root_node)
      modified_since(dag, root_node.path, root_node.dependencies)
    end

    def lookup(dag, dep)
      dag.nodes[dep.path.to_s] || dep
    end

    def modified_since(dag, path, deps)
      actual_deps = deps.map{ lookup(dag, _1) }

      grand_children = actual_deps.map { |dep|        
        modified_since(dag, dep.path, dep.dependencies) 
      }
      children = actual_deps.select do |dep|
        if File.exist?(dep.path) && File.exist?(path)
          File.mtime(dep.path) > File.mtime(path)
        else
          true
        end
      end
      (grand_children + children).flatten
    end

    def die(reason)
      warn reason
      exit 1
    end
  end
end

args = ARGV.group_by { _1 =~ /^\-/ }
raise 'no file task given' unless args[nil]
runner = Suburb::Runner.new
args[nil].each { |file|
  runner.run(File.expand_path(file), Array(args[0]).include?('-f'))
}
