#!/usr/bin/env ruby

# frozen_string_literal: true

require_relative '../lib/node'
require_relative '../lib/dsl/spec'
require_relative '../lib/runner'
require 'prettyprint'
require 'tty-progressbar'
require 'tty-option'
require 'tty-logger'

class Command
  include TTY::Option

  def initialize
    super
    @log_file = TTY::Logger.new do |config|
      config.handlers = [[:stream, { output: File.open('suburb.log', 'w'), formatter: :text }]]
    end
    @terminal_output = TTY::Logger.new
  end

  usage do
    program 'suburb'

    desc 'The simplest build graph in the world'

    no_command

    example <<~EOS
      Build and watch website
        $ suburb -w dist/index.html

      Run tests, even if no dependencies changed
        $ suburb -f test-results.txt

      Clean (remove) file all dependencies
        $ suburb --clean
    EOS
  end

  argument :files do
    arity zero_or_more
    desc 'The relative path(s) of the file(s) you want to build.'
  end

  flag :force do
    short '-f'
    long '--force'
    desc 'Force rebuilding file and all dependencies.'
  end

  flag :watch do
    short '-w'
    long '--watch'
    desc 'Watch file and dependencies (including transitive) for changes and rebuild as needed.'
  end

  flag :tree do
    short '-t'
    long '--show-tree'
    desc 'Show a visual graph of the dependency tree.'
  end

  flag :clean do
    short '-c'
    long '--clean'
    desc 'Delete file and all its (transitive) dependencies.'
  end

  flag :help do
    short '-h'
    long '--help'
    desc 'Print usage'
  end

  def run
    if params[:help]
      print help
    elsif params.errors.any?
      @terminal_output.error params.errors.summary
      print help
    else
      run_suburb
    end
  end

  def run_suburb    
    begin
      start_time = Time.new
      runner = Suburb::Runner.new(@log_file, @terminal_output)
      Array(params[:files]).each do |file|
        file_path = File.expand_path(file)
        if params[:clean]
          runner.clean(file_path)
        elsif params[:tree]
          runner.show_tree(file_path)
        else
          runner.run(file_path, force: params[:force])
        end
      end
      @terminal_output.info "Completed in #{format_elapsed(start_time, Time.new)}."
      @terminal_output.info 'Log file: cat ./suburb.log'
    rescue Suburb::RuntimeError => e
      @log_file.error e
      @terminal_output.error e.message
      end_time = Time.new
      @terminal_output.info "Errored after #{format_elapsed(start_time, Time.new)}."
      @terminal_output.info 'Complete log: cat ./suburb.log'
    end
  end

  def format_elapsed(start_time, end_time)
    elapsed = end_time - start_time
    if elapsed < 1.0
      "#{'%.0f' % (elapsed * 1000)} ms"
    elsif elapsed < 60
      "#{'%.0f' % elapsed} seconds"
    else
      "#{'%.0f' % (elapsed / 60)}:{'%.0f' % (elapsed % 60)}"
    end
  end
end

cmd = Command.new
cmd.parse
cmd.run
